import sys
import sqlite3
import os
from PyQt5.QtWidgets import (
    QApplication, QWidget, QLabel, QLineEdit, QPushButton, QVBoxLayout,
    QHBoxLayout, QMessageBox, QTableWidget, QTableWidgetItem, QDateEdit
)
from PyQt5.QtCore import QDate
from datetime import datetime


class ClinicApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Clinic Appointment System")
        self.setGeometry(200, 200, 600, 400)

        # --- Database connection ---
        self.db_path = os.path.join(os.path.dirname(__file__), "clinic.db")
        self.conn = sqlite3.connect(self.db_path)
        self.cursor = self.conn.cursor()

        # Create table if not exists
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS appointments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT,
                doctor TEXT,
                date TEXT,
                time TEXT
            )
        """)
        self.conn.commit()

        # --- Input fields ---
        self.name_label = QLabel("Patient Name:")
        self.name_input = QLineEdit()

        self.doctor_label = QLabel("Doctor:")
        self.doctor_input = QLineEdit()

        self.date_label = QLabel("Date:")
        self.date_input = QDateEdit()
        self.date_input.setCalendarPopup(True)  # enable calendar
        self.date_input.setDate(QDate.currentDate())  # default today

        self.time_label = QLabel("Time (HH:MM AM/PM):")
        self.time_input = QLineEdit()
        self.time_input.editingFinished.connect(self.format_time)  # format when done typing

        # --- Buttons ---
        self.book_button = QPushButton("Book Appointment")
        self.view_button = QPushButton("View Appointments")
        self.cancel_button = QPushButton("Cancel Appointment")

        self.book_button.clicked.connect(self.book_appointment)
        self.view_button.clicked.connect(self.view_appointments)
        self.cancel_button.clicked.connect(self.cancel_appointment)

        # --- Table for appointments ---
        self.table = QTableWidget()
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(["ID", "Name", "Doctor", "Date", "Time"])
        self.table.setColumnHidden(0, True)  # Hide ID column

        # --- Layout ---
        layout = QVBoxLayout()
        layout.addWidget(self.name_label)
        layout.addWidget(self.name_input)
        layout.addWidget(self.doctor_label)
        layout.addWidget(self.doctor_input)
        layout.addWidget(self.date_label)
        layout.addWidget(self.date_input)
        layout.addWidget(self.time_label)
        layout.addWidget(self.time_input)

        hlayout = QHBoxLayout()
        hlayout.addWidget(self.book_button)
        hlayout.addWidget(self.view_button)
        hlayout.addWidget(self.cancel_button)
        layout.addLayout(hlayout)

        layout.addWidget(self.table)
        self.setLayout(layout)

    def format_time(self):
        """Format time input to HH:MM AM/PM if valid"""
        text = self.time_input.text().strip()
        if not text:
            return
        try:
            # Try parsing user input
            parsed_time = datetime.strptime(text, "%H:%M")  # e.g. 14:30
        except ValueError:
            try:
                parsed_time = datetime.strptime(text, "%I:%M %p")  # e.g. 2:30 PM
            except ValueError:
                QMessageBox.warning(self, "Invalid Time", "Please enter time in HH:MM or HH:MM AM/PM format.")
                self.time_input.clear()
                return

        # Format properly
        self.time_input.setText(parsed_time.strftime("%I:%M %p"))

    def book_appointment(self):
        name = self.name_input.text()
        doctor = self.doctor_input.text()
        date = self.date_input.date().toString("yyyy-MM-dd")  # Get selected date
        time = self.time_input.text()

        if not name or not doctor or not time:
            QMessageBox.warning(self, "Error", "All fields are required!")
            return

        self.cursor.execute("INSERT INTO appointments (name, doctor, date, time) VALUES (?, ?, ?, ?)",
                            (name, doctor, date, time))
        self.conn.commit()
        QMessageBox.information(self, "Success", "Appointment booked successfully!")
        self.clear_inputs()
        self.view_appointments()

    def view_appointments(self):
        self.cursor.execute("SELECT id, name, doctor, date, time FROM appointments")
        rows = self.cursor.fetchall()

        self.table.setRowCount(len(rows))
        for i, row in enumerate(rows):
            for j, val in enumerate(row):
                self.table.setItem(i, j, QTableWidgetItem(str(val)))

    def cancel_appointment(self):
        selected_row = self.table.currentRow()
        if selected_row < 0:
            QMessageBox.warning(self, "Error", "Please select an appointment to cancel!")
            return

        appointment_id = self.table.item(selected_row, 0).text()

        confirm = QMessageBox.question(
            self,
            "Confirm Cancel",
            "Are you sure you want to cancel this appointment?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if confirm == QMessageBox.Yes:
            self.cursor.execute("DELETE FROM appointments WHERE id=?", (appointment_id,))
            self.conn.commit()
            QMessageBox.information(self, "Cancelled", "Appointment cancelled successfully!")
            self.view_appointments()

    def clear_inputs(self):
        self.name_input.clear()
        self.doctor_input.clear()
        self.date_input.setDate(QDate.currentDate())  # reset to today
        self.time_input.clear()

    def closeEvent(self, event):
        # Close DB when app closes
        self.conn.close()
        event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = ClinicApp()
    window.show()
    sys.exit(app.exec_())
